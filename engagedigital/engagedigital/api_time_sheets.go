/*
 * Engage Digital API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package engagedigital

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type TimeSheetsApiService service

/*
TimeSheetsApiService Creating a time sheet
This method creates a time sheet. In case of success it renders the time sheet, otherwise, it renders an error (422 HTTP code).  Authorization​: only users that can create time sheet.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param label The label of the time sheet.
 * @param optional nil or *CreateTimeSheetOpts - Optional Parameters:
 * @param "Active" (optional.Bool) -  true or false, this field is used to enable/disable a time sheet.
 * @param "SourceIds" (optional.Interface of []string) -  An array containing id of each source using your time sheet.
 * @param "HolidaysRegion" (optional.String) -  A string containing the first two letters of your country (example: \"fr\"/\"en\"/\"es\"), useful to bootstrap default holidays following to a country.
 * @param "Holidays" (optional.String) -  An array containing one or more hash of holidays, a holiday must contain a name (string) and a date (string), the date must be in a valid format, a valid format is a format corresponding to your domain’s locale).
 * @param "MondayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. For example: “a-b,c-d”: “a” is the beginning of the first interval of the day, “b” is the ending of the first interval of the day, “c” is the beginning of the second interval of the day, “d” is the ending of the second interval of the day
 * @param "TuesdayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "WednesdayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "ThursdayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "FridayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "SaturdayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "SundayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
@return TimeSheet
*/

type CreateTimeSheetOpts struct {
	Active         optional.Bool
	SourceIds      optional.Interface
	HolidaysRegion optional.String
	Holidays       optional.String
	MondayHours    optional.String
	TuesdayHours   optional.String
	WednesdayHours optional.String
	ThursdayHours  optional.String
	FridayHours    optional.String
	SaturdayHours  optional.String
	SundayHours    optional.String
}

func (a *TimeSheetsApiService) CreateTimeSheet(ctx context.Context, label string, localVarOptionals *CreateTimeSheetOpts) (TimeSheet, *http.Response, error) {
	var (
		localVarHttpMethod   = http.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TimeSheet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/time_sheets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Active.IsSet() {
		localVarQueryParams.Add("active", parameterToString(localVarOptionals.Active.Value(), ""))
	}
	localVarQueryParams.Add("label", parameterToString(label, ""))
	if localVarOptionals != nil && localVarOptionals.SourceIds.IsSet() {
		t := localVarOptionals.SourceIds.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("source_ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("source_ids", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.HolidaysRegion.IsSet() {
		localVarQueryParams.Add("holidays_region", parameterToString(localVarOptionals.HolidaysRegion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Holidays.IsSet() {
		localVarQueryParams.Add("holidays", parameterToString(localVarOptionals.Holidays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MondayHours.IsSet() {
		localVarQueryParams.Add("monday_hours", parameterToString(localVarOptionals.MondayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TuesdayHours.IsSet() {
		localVarQueryParams.Add("tuesday_hours", parameterToString(localVarOptionals.TuesdayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WednesdayHours.IsSet() {
		localVarQueryParams.Add("wednesday_hours", parameterToString(localVarOptionals.WednesdayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThursdayHours.IsSet() {
		localVarQueryParams.Add("thursday_hours", parameterToString(localVarOptionals.ThursdayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FridayHours.IsSet() {
		localVarQueryParams.Add("friday_hours", parameterToString(localVarOptionals.FridayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SaturdayHours.IsSet() {
		localVarQueryParams.Add("saturday_hours", parameterToString(localVarOptionals.SaturdayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SundayHours.IsSet() {
		localVarQueryParams.Add("sunday_hours", parameterToString(localVarOptionals.SundayHours.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TimeSheet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TimeSheetsApiService Deleting a time sheet
This method destroys an existing time sheet. It renders time sheet itself. It renders a 404 if id is invalid.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param timeSheetId
@return TimeSheet
*/
func (a *TimeSheetsApiService) DeleteTimeSheet(ctx context.Context, timeSheetId string) (TimeSheet, *http.Response, error) {
	var (
		localVarHttpMethod   = http.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TimeSheet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/time_sheets/{timeSheetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeSheetId"+"}", fmt.Sprintf("%v", timeSheetId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TimeSheet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TimeSheetsApiService Getting all time sheets
This method renders time sheets ordered by active and label.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GetAllTimeSheetsOpts - Optional Parameters:
 * @param "Offset" (optional.Int32) -  The record index to start. Default value is 0.
 * @param "Limit" (optional.Int32) -  The max number of records to return. Default value is 30, max value is 150.
@return GetAllTimeSheetsResponse
*/

type GetAllTimeSheetsOpts struct {
	Offset optional.Int32
	Limit  optional.Int32
}

func (a *TimeSheetsApiService) GetAllTimeSheets(ctx context.Context, localVarOptionals *GetAllTimeSheetsOpts) (GetAllTimeSheetsResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = http.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetAllTimeSheetsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/time_sheets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllTimeSheetsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TimeSheetsApiService Getting a time sheet from its id
This method renders a time sheet from given id.  Authorization​: only users that can see time sheets in administration section.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param timeSheetId
@return TimeSheet
*/
func (a *TimeSheetsApiService) GetTimeSheet(ctx context.Context, timeSheetId string) (TimeSheet, *http.Response, error) {
	var (
		localVarHttpMethod   = http.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TimeSheet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/time_sheets/{timeSheetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeSheetId"+"}", fmt.Sprintf("%v", timeSheetId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TimeSheet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TimeSheetsApiService Updating a time sheet
This method updates an existing team from given attributes and renders it in case of success.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param timeSheetId
 * @param optional nil or *UpdateTimeSheetOpts - Optional Parameters:
 * @param "Active" (optional.Bool) -  true or false, this field is used to enable/disable a time sheet.
 * @param "Label" (optional.String) -  The label of the time sheet.
 * @param "SourceIds" (optional.Interface of []string) -  An array containing id of each source using your time sheet.
 * @param "Holidays" (optional.String) -  An array containing one or more hash of holidays, a holiday must contain a name (string) and a date (string), the date must be in a valid format, a valid format is a format corresponding to your domain’s locale).
 * @param "MondayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. For example: “a-b,c-d”: “a” is the beginning of the first interval of the day, “b” is the ending of the first interval of the day, “c” is the beginning of the second interval of the day, “d” is the ending of the second interval of the day
 * @param "TuesdayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "WednesdayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "ThursdayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "FridayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "SaturdayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
 * @param "SundayHours" (optional.String) -  this field define the time intervals of the day (in secs). An empty string means that there are no business hours on this day. See `monday_hours` for the format.
@return TimeSheet
*/

type UpdateTimeSheetOpts struct {
	Active         optional.Bool
	Label          optional.String
	SourceIds      optional.Interface
	Holidays       optional.String
	MondayHours    optional.String
	TuesdayHours   optional.String
	WednesdayHours optional.String
	ThursdayHours  optional.String
	FridayHours    optional.String
	SaturdayHours  optional.String
	SundayHours    optional.String
}

func (a *TimeSheetsApiService) UpdateTimeSheet(ctx context.Context, timeSheetId string, localVarOptionals *UpdateTimeSheetOpts) (TimeSheet, *http.Response, error) {
	var (
		localVarHttpMethod   = http.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TimeSheet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/time_sheets/{timeSheetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeSheetId"+"}", fmt.Sprintf("%v", timeSheetId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Active.IsSet() {
		localVarQueryParams.Add("active", parameterToString(localVarOptionals.Active.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIds.IsSet() {
		t := localVarOptionals.SourceIds.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("source_ids[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("source_ids[]", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Holidays.IsSet() {
		localVarQueryParams.Add("holidays", parameterToString(localVarOptionals.Holidays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MondayHours.IsSet() {
		localVarQueryParams.Add("monday_hours", parameterToString(localVarOptionals.MondayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TuesdayHours.IsSet() {
		localVarQueryParams.Add("tuesday_hours", parameterToString(localVarOptionals.TuesdayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WednesdayHours.IsSet() {
		localVarQueryParams.Add("wednesday_hours", parameterToString(localVarOptionals.WednesdayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThursdayHours.IsSet() {
		localVarQueryParams.Add("thursday_hours", parameterToString(localVarOptionals.ThursdayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FridayHours.IsSet() {
		localVarQueryParams.Add("friday_hours", parameterToString(localVarOptionals.FridayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SaturdayHours.IsSet() {
		localVarQueryParams.Add("saturday_hours", parameterToString(localVarOptionals.SaturdayHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SundayHours.IsSet() {
		localVarQueryParams.Add("sunday_hours", parameterToString(localVarOptionals.SundayHours.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TimeSheet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
