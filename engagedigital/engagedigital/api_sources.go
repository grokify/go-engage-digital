/*
 * Engage Digital API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package engagedigital

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type SourcesApiService service

/*
SourcesApiService Getting all sources
This method renders sources ordered by creation date (ascending).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GetAllSourcesOpts - Optional Parameters:
 * @param "Offset" (optional.Int32) -  The record index to start. Default value is 0.
 * @param "Limit" (optional.Int32) -  The max number of records to return. Default value is 30, max value is 150.
@return GetAllSourcesResponse
*/

type GetAllSourcesOpts struct {
	Offset optional.Int32
	Limit  optional.Int32
}

func (a *SourcesApiService) GetAllSources(ctx context.Context, localVarOptionals *GetAllSourcesOpts) (GetAllSourcesResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = http.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetAllSourcesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/content_sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllSourcesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SourcesApiService Getting a source from its id
This method renders a source from given id.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceId
@return Source
*/
func (a *SourcesApiService) GetSource(ctx context.Context, sourceId string) (Source, *http.Response, error) {
	var (
		localVarHttpMethod   = http.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Source
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/content_sources/{sourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceId"+"}", fmt.Sprintf("%v", sourceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Source
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SourcesApiService Updating a source
This method updates an existing source from given attributes and renders it in case of success.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceId
 * @param optional nil or *UpdateSourceOpts - Optional Parameters:
 * @param "Name" (optional.String) -  Source name
 * @param "Active" (optional.Bool) -  Activate/deactivate the source (Boolean)
 * @param "ChannelId" (optional.String) -  Channel
 * @param "Color" (optional.Int32) -  Color of the icon (see S​ ource colors​) (Integer)
 * @param "SlaResponse" (optional.Int32) -  Response time (seconds)
 * @param "SlaExpiredStrategy" (optional.String) -  SLA expired strategy (\"max\", \"half\" or \"base\")
 * @param "InterventionMessagesBoost" (optional.Int32) -  Priority boost of messages with intervention (Integer)
 * @param "TransferredTasksBoost" (optional.Int32) -  Priority boost of transferred tasks (Integer)
 * @param "HiddenFromStats" (optional.Bool) -  Hide from statistics (Boolean)
 * @param "DefaultCategoryIds" (optional.Interface of []string) -  Default categories
 * @param "UserThreadDefaultCategoryIds" (optional.Interface of []string) -  Default categories (agent messages)
 * @param "DefaultContentLanguage" (optional.String) -  Default content language
 * @param "AutoDetectContentLanguage" (optional.Bool) -  Auto-detect content language (Boolean)
 * @param "ContentArchiving" (optional.Bool) -  Automatic archiving of old contents (Boolean)
 * @param "ContentArchivingPeriod" (optional.Int32) -  Archive contents older than (seconds)
@return Source
*/

type UpdateSourceOpts struct {
	Name                         optional.String
	Active                       optional.Bool
	ChannelId                    optional.String
	Color                        optional.Int32
	SlaResponse                  optional.Int32
	SlaExpiredStrategy           optional.String
	InterventionMessagesBoost    optional.Int32
	TransferredTasksBoost        optional.Int32
	HiddenFromStats              optional.Bool
	DefaultCategoryIds           optional.Interface
	UserThreadDefaultCategoryIds optional.Interface
	DefaultContentLanguage       optional.String
	AutoDetectContentLanguage    optional.Bool
	ContentArchiving             optional.Bool
	ContentArchivingPeriod       optional.Int32
}

func (a *SourcesApiService) UpdateSource(ctx context.Context, sourceId string, localVarOptionals *UpdateSourceOpts) (Source, *http.Response, error) {
	var (
		localVarHttpMethod   = http.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Source
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/content_sources/{sourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceId"+"}", fmt.Sprintf("%v", sourceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Active.IsSet() {
		localVarQueryParams.Add("active", parameterToString(localVarOptionals.Active.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChannelId.IsSet() {
		localVarQueryParams.Add("channel_id", parameterToString(localVarOptionals.ChannelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Color.IsSet() {
		localVarQueryParams.Add("color", parameterToString(localVarOptionals.Color.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlaResponse.IsSet() {
		localVarQueryParams.Add("sla_response", parameterToString(localVarOptionals.SlaResponse.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlaExpiredStrategy.IsSet() {
		localVarQueryParams.Add("sla_expired_strategy", parameterToString(localVarOptionals.SlaExpiredStrategy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterventionMessagesBoost.IsSet() {
		localVarQueryParams.Add("intervention_messages_boost", parameterToString(localVarOptionals.InterventionMessagesBoost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransferredTasksBoost.IsSet() {
		localVarQueryParams.Add("transferred_tasks_boost", parameterToString(localVarOptionals.TransferredTasksBoost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HiddenFromStats.IsSet() {
		localVarQueryParams.Add("hidden_from_stats", parameterToString(localVarOptionals.HiddenFromStats.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DefaultCategoryIds.IsSet() {
		t := localVarOptionals.DefaultCategoryIds.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("default_category_ids[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("default_category_ids[]", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.UserThreadDefaultCategoryIds.IsSet() {
		t := localVarOptionals.UserThreadDefaultCategoryIds.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("user_thread_default_category_ids[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("user_thread_default_category_ids[]", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.DefaultContentLanguage.IsSet() {
		localVarQueryParams.Add("default_content_language", parameterToString(localVarOptionals.DefaultContentLanguage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutoDetectContentLanguage.IsSet() {
		localVarQueryParams.Add("auto_detect_content_language", parameterToString(localVarOptionals.AutoDetectContentLanguage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentArchiving.IsSet() {
		localVarQueryParams.Add("content_archiving", parameterToString(localVarOptionals.ContentArchiving.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentArchivingPeriod.IsSet() {
		localVarQueryParams.Add("content_archiving_period", parameterToString(localVarOptionals.ContentArchivingPeriod.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Source
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
